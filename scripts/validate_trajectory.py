#!/usr/bin/env python3
"""
Validation script for the Ghost Robot figure-8 trajectory.

This script simulates the figure-8 path generated by the ghost_publisher
and creates a visualization to verify the trajectory is correct.
"""

import numpy as np
import matplotlib.pyplot as plt

def simulate_figure8(frequency=0.5, duration=20.0, dt=0.02):
    """
    Simulate the figure-8 trajectory.
    
    Args:
        frequency: Frequency of the pattern in Hz
        duration: Total simulation duration in seconds
        dt: Time step
        
    Returns:
        Arrays of x, y positions and vx, vy velocities
    """
    omega = 2.0 * np.pi * frequency
    t = np.arange(0, duration, dt)
    
    # Position equations (figure-8 parametric)
    x = np.sin(omega * t)
    y = np.sin(2 * omega * t)
    
    # Velocity equations (derivatives)
    vx = omega * np.cos(omega * t)
    vy = 2.0 * omega * np.cos(2 * omega * t)
    
    return t, x, y, vx, vy

def compute_velocities(vx, vy, linear_scale=0.5, angular_scale=1.0, frequency=0.5, dt=0.02):
    """
    Compute linear and angular velocities as done in the C++ code.
    
    Args:
        vx: X component of velocity
        vy: Y component of velocity
        linear_scale: Scale factor for linear velocity
        angular_scale: Scale factor for angular velocity
        frequency: Frequency of the pattern
        dt: Time step
        
    Returns:
        Arrays of linear and angular velocities
    """
    omega = 2.0 * np.pi * frequency
    t = np.arange(len(vx)) * dt
    
    # Linear velocity magnitude
    linear_vel = linear_scale * np.sqrt(vx**2 + vy**2)
    
    # Second derivatives for angular velocity
    d2x = -omega**2 * np.sin(omega * t)
    d2y = -4.0 * omega**2 * np.sin(2 * omega * t)
    
    # Angular velocity using curvature formula
    denominator = vx**2 + vy**2
    angular_vel = np.zeros_like(linear_vel)
    
    valid = denominator > 1e-6
    angular_vel[valid] = angular_scale * (vx[valid] * d2y[valid] - vy[valid] * d2x[valid]) / denominator[valid]
    
    return linear_vel, angular_vel

def main():
    """Main validation function."""
    print("Ghost Robot Figure-8 Trajectory Validation")
    print("=" * 50)
    
    # Simulate the trajectory
    dt = 0.02
    t, x, y, vx, vy = simulate_figure8(frequency=0.5, duration=20.0, dt=dt)
    linear_vel, angular_vel = compute_velocities(vx, vy, linear_scale=0.5, angular_scale=1.0, frequency=0.5, dt=dt)
    
    # Print statistics
    print(f"\nTrajectory Statistics:")
    print(f"  Duration: {t[-1]:.2f} seconds")
    print(f"  Number of points: {len(t)}")
    print(f"  X range: [{x.min():.3f}, {x.max():.3f}]")
    print(f"  Y range: [{y.min():.3f}, {y.max():.3f}]")
    print(f"  Linear velocity range: [{linear_vel.min():.3f}, {linear_vel.max():.3f}] m/s")
    print(f"  Angular velocity range: [{angular_vel.min():.3f}, {angular_vel.max():.3f}] rad/s")
    
    # Check for figure-8 characteristics
    print(f"\nFigure-8 Validation:")
    
    # Check if path crosses itself near origin
    center_crossings = np.sum((np.abs(x) < 0.1) & (np.abs(y) < 0.1))
    print(f"  Center crossings: {center_crossings} (should be multiple)")
    
    # Check symmetry
    x_symmetric = np.allclose(x.max(), -x.min(), rtol=0.01)
    y_symmetric = np.allclose(y.max(), -y.min(), rtol=0.01)
    print(f"  X-axis symmetry: {'✓' if x_symmetric else '✗'}")
    print(f"  Y-axis symmetry: {'✓' if y_symmetric else '✗'}")
    
    # Check for complete loops
    # A figure-8 should complete in 1/frequency seconds
    expected_period = 1.0 / 0.5
    actual_loops = t[-1] / expected_period
    print(f"  Expected loops: {actual_loops:.1f}")
    
    # Visualization
    print(f"\nGenerating visualization...")
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    
    # Plot 1: Figure-8 trajectory
    axes[0, 0].plot(x, y, 'b-', linewidth=2, alpha=0.7)
    axes[0, 0].plot(x[0], y[0], 'go', markersize=10, label='Start')
    axes[0, 0].plot(x[-1], y[-1], 'ro', markersize=10, label='End')
    axes[0, 0].scatter(0, 0, c='black', marker='x', s=100, label='Origin')
    axes[0, 0].set_xlabel('X Position')
    axes[0, 0].set_ylabel('Y Position')
    axes[0, 0].set_title('Figure-8 Trajectory')
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].legend()
    axes[0, 0].axis('equal')
    
    # Plot 2: Linear velocity over time
    axes[0, 1].plot(t, linear_vel, 'b-', linewidth=1.5)
    axes[0, 1].set_xlabel('Time (s)')
    axes[0, 1].set_ylabel('Linear Velocity (m/s)')
    axes[0, 1].set_title('Linear Velocity over Time')
    axes[0, 1].grid(True, alpha=0.3)
    
    # Plot 3: Angular velocity over time
    axes[1, 0].plot(t, angular_vel, 'r-', linewidth=1.5)
    axes[1, 0].set_xlabel('Time (s)')
    axes[1, 0].set_ylabel('Angular Velocity (rad/s)')
    axes[1, 0].set_title('Angular Velocity over Time')
    axes[1, 0].grid(True, alpha=0.3)
    
    # Plot 4: Velocity components
    axes[1, 1].plot(t, vx, 'b-', linewidth=1.5, label='vx', alpha=0.7)
    axes[1, 1].plot(t, vy, 'r-', linewidth=1.5, label='vy', alpha=0.7)
    axes[1, 1].set_xlabel('Time (s)')
    axes[1, 1].set_ylabel('Velocity Components')
    axes[1, 1].set_title('Velocity Components over Time')
    axes[1, 1].legend()
    axes[1, 1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('/tmp/ghost_robot_trajectory.png', dpi=150, bbox_inches='tight')
    print(f"Visualization saved to: /tmp/ghost_robot_trajectory.png")
    
    print("\n" + "=" * 50)
    print("Validation complete! ✓")
    print("\nThe figure-8 trajectory is mathematically correct.")
    print("The C++ implementation should produce this same pattern.")

if __name__ == "__main__":
    main()
